
// Calculates one step of the state-variable filter
fun svf_step(input,g,q,sel:int) : real {
   mem dlow, dband;
   val low = dlow + g * dband;
   val high = input - low - q*dband;
   val band = g * high + dband;
   val notch = high + low;

   dband = Util.soft_saturate(band);
   dlow  = Util.soft_saturate(low);
   val output =
      if sel == 0 then low else
      if sel == 1 then high else
      if sel == 2 then band else
      notch;
   return output;
}

fun cv_to_g(cv) @[table(size=128,min=-0.3,max=1.0)] {
  val pitch = cv * 120.0 + 48.0;
  val f = 8.175798915643707 * exp(0.057762265046662105*pitch);
  return 2.0 * sin(3.141592653589793 * f / (2.0 * 44100.0));
}

// Main function for the state-variable filter with 2x of oversampling
fun flt_svf(input,cv,q,sel){
   mem g;
   val fix_cv = clip(cv,-0.3, 6.0);
   val fix_q = clip(q, 0.0, 1.0);
   fix_q = Util.map(fix_q, 0.0, 1.0, 2.0, 0.0);

   // 2x oversampling and controlling with cv
   if(Util.change(fix_cv)){
      g = cv_to_g(fix_cv);
   }

   // In Vult oversamplig in very easy!
   val x1 = step:svf_step(input,g,fix_q,sel);
   val x2 = step:svf_step(input,g,fix_q,sel);

   return (x1+x2)/2.;
}

fun process(input,cv,q,sel) {
  return flt_svf(input,cv,q,sel);
}
and noteOn(note:int,velocity:int,channel:int){ }
and noteOff(note:int,channel:int){ }
and controlChange(control:int,value:int,channel:int){ }
and default(){ }